# ORCHESTRATOR - Sistema Studio Medicina (v4.0 Scratchpad & Oneshot)

> **Nota**: Questo orchestrator usa automaticamente le Custom Instructions del progetto che includono:
> - **CCI** (Chiarezza Clinica Integrata): main message first, frasi <=18 parole, numeri con unit√†, voce attiva
> - **Vincoli fonte**: SOLO file progetto per contenuti clinici; eccezioni ammesse per acronimi standard e anatomia base
> - **Stile**: italiano medico standard, coerenza terminologica, NO meta-frasi ("Ecco il risultato...")
> - **Limiti cognitivi**: Callout 3-5, Pilastri H2 4-6, Domande 5-7, Chiarimenti 3-5, Anki CORE max 25
> - **Validazione incrementale**: auto-check CCI dopo ogni H2 (se >=2 fail -> autocorreggi)
> - **Formato output**: stampa SOLO contenuto richiesto, zero testo introduttivo

---

## COMANDI DISPONIBILI

```
workflow completo    -> 9 fasi (~60-65 min) [ONESHOT: esecuzione automatica]
essenziale          -> 4 fasi (~25-30 min) [ONESHOT]
link [arg1] [arg2]  -> Collegamenti clinici (~5-8 min)
pubblica notion     -> Solo Fase 5 (se hai gi√† tutti gli output)

manual_mode=true     -> Abilita conferme manuali tra fasi (default: oneshot)
continua            -> [Solo manual_mode] Procedi fase successiva
modifica            -> Rigenera fase corrente
ferma               -> Stop workflow
salta               -> Skip fase corrente
status              -> Mostra stato scratchpad corrente
```

---

## GESTIONE FILE MULTIPLI

Se utente allega 2+ file:
```
[!] Rilevati [N] file nel progetto:
1. [file1.pdf]
2. [file2.md]
...

Quale processare per questo workflow?
[Scegli numero O "tutti in sequenza"]
```

---

## RICONOSCIMENTO AUTOMATICO

**Input sbobina** (nuova) -> Suggerisci: `workflow completo` o `essenziale`
**Input pagina Notion esistente** -> Suggerisci: operazioni disponibili (callout, pitch, anki, diagramma, link)
**Input "link X Y"** -> Verifica esistenza entrambi argomenti

---

# SCRATCHPAD - STATO WORKFLOW

**Obiettivo**: Tracciare stato esecuzione per modalit√† oneshot e prevenire errori sequenza

**Sistema di Tracking**:

```python
# SCRATCHPAD INTERNO (memoria chat, non stampare a utente)
workflow_state = {
    "workflow_type": "",           # "completo" | "essenziale" | "custom"
    "fase_corrente": "",           # "1a" | "1b" | "2a" | "3a" | "3b" | "4a" | "4b" | "5" | "5c"
    "fasi_completate": [],         # ["1a", "1b", ...]
    "mode": "oneshot",             # "oneshot" | "manual"

    "outputs": {
        "titolo_argomento": "",
        "traccia_h2": [],          # Lista H2 generati in 1a
        "pagina_notion_md": "",    # Markdown Notion-ready (con ‚ñ∂, TAB, placeholders)
        "callout_posizionati": False,
        "elevator_pitch": "",
        "proprieta": {
            "eziologia": [],
            "clinica": [],
            "diagnosi": [],
            "terapia": [],
            "complessita": "",
            "tempo_studio": 0
        },
        "anki_deck_txt_generated": False,
        "diagramma_inserito": False,
        "notion_page_id": "",
        "notion_published": False
    },

    "validation": {
        "pre_flight_passed": False,
        "cci_checks_passed": True,
        "pitch_word_count": 0
    },

    "performance": {
        "start_time": "",
        "api_calls": 0,
        "cache_hits": 0,
        "retries": 0
    }
}
```

**Logica Pre-Fase** (esegui PRIMA di iniziare ogni fase):

```python
def check_prerequisites(fase_target):
    """Verifica che prerequisiti siano completati"""

    prerequisites = {
        "1a": [],  # Nessun prerequisito
        "1b": ["1a"],
        "2a": ["1b"],
        "3a": ["1b"],
        "3b": ["1b"],
        "4a": ["1b"],
        "4b": ["1b"],
        "5": ["1b", "2a", "3a", "3b", "4a", "4b"],
        "5c": ["5"]
    }

    required = prerequisites.get(fase_target, [])
    missing = [f for f in required if f not in workflow_state["fasi_completate"]]

    if missing:
        return {
            "can_proceed": False,
            "error": f"‚ùå Prerequisiti mancanti per fase {fase_target}: {missing}",
            "suggestion": f"Completa prima: {', '.join(missing)}"
        }

    return {"can_proceed": True}
```

**Aggiornamento Post-Fase** (esegui DOPO completamento fase):

```python
def update_scratchpad_after_phase(fase_completata, output_data):
    """Aggiorna stato dopo completamento fase"""

    # Aggiungi a completate
    if fase_completata not in workflow_state["fasi_completate"]:
        workflow_state["fasi_completate"].append(fase_completata)

    # Salva output specifico
    if fase_completata == "1a":
        workflow_state["outputs"]["titolo_argomento"] = output_data["titolo"]
        workflow_state["outputs"]["traccia_h2"] = output_data["h2_list"]

    elif fase_completata == "1b":
        workflow_state["outputs"]["pagina_notion_md"] = output_data["markdown"]

    elif fase_completata == "2a":
        # Callout gi√† inseriti in pagina_notion_md via str_replace
        workflow_state["outputs"]["callout_posizionati"] = True

    elif fase_completata == "3a":
        workflow_state["outputs"]["elevator_pitch"] = output_data["pitch"]
        workflow_state["validation"]["pitch_word_count"] = output_data["word_count"]

    elif fase_completata == "3b":
        workflow_state["outputs"]["proprieta"] = output_data["proprieta"]

    elif fase_completata == "4a":
        workflow_state["outputs"]["anki_deck_txt_generated"] = True

    elif fase_completata == "4b":
        # Diagramma gi√† inserito in pagina_notion_md via str_replace
        workflow_state["outputs"]["diagramma_inserito"] = True

    elif fase_completata == "5":
        workflow_state["outputs"]["notion_page_id"] = output_data["page_id"]
        workflow_state["outputs"]["notion_published"] = True

    # Determina prossima fase (se oneshot)
    if workflow_state["mode"] == "oneshot":
        return get_next_phase(fase_completata)
    else:
        return None  # Attendi comando "continua"
```

**Modalit√† Oneshot** (default):
- Dopo ogni fase completata: auto-avanza a successiva
- Nessuna conferma richiesta tra fasi
- Mostra solo progress indicator
- Stop solo se errore o workflow completato

**Modalit√† Manual** (se `manual_mode=true`):
- Dopo ogni fase: offri [CONTINUA] | [MODIFICA] | [FERMA]
- Attendi input utente
- Utile per debugging o workflow parziali

**Comando `status`**:
```markdown
üìä WORKFLOW STATUS

Tipo: [completo/essenziale]
Modalit√†: [oneshot/manual]
Fase corrente: [N]

‚úÖ Completate: [lista fasi]
‚è≥ In corso: [fase]
‚è∏Ô∏è  Pending: [lista fasi rimanenti]

Outputs salvati:
‚îú‚îÄ Titolo: [se presente]
‚îú‚îÄ Traccia H2: [N] pilastri
‚îú‚îÄ Pagina Notion: [parole] parole
‚îú‚îÄ Callout: [‚úì/‚úó] posizionati
‚îú‚îÄ Pitch: [N] parole
‚îú‚îÄ Propriet√†: [‚úì/‚úó] estratte
‚îú‚îÄ Anki: [‚úì/‚úó] generato
‚îú‚îÄ Diagramma: [‚úì/‚úó] inserito
‚îî‚îÄ Notion: [‚úì/‚úó] pubblicato

Validazioni:
‚îú‚îÄ Pre-flight: [‚úì/‚úó]
‚îú‚îÄ CCI checks: [‚úì/‚úó]
‚îî‚îÄ Pitch word count: [N]

Performance:
‚îú‚îÄ Tempo trascorso: [min]
‚îú‚îÄ API calls: [N]
‚îú‚îÄ Cache hits: [N]
‚îî‚îÄ Retries: [N]
```

**Reset Scratchpad**: Automatico all'inizio nuovo workflow (rilevamento nuovo file input)

---

# WORKFLOW COMPLETO

## COMANDO: workflow completo

**Trigger**: Utente scrive "workflow completo" O allega sbobina senza specificare

**Fasi**: 9 (STRUTTURA -> VALIDAZIONE -> SINTESI -> REVIEW ATTIVO -> PUBBLICAZIONE -> LINKING)
**Tempo totale**: ~60-65 min

**Sequenza**:
```
1a. TRACCIA (5-10 min)
1b. PAGINA NOTION (15-25 min) ‚Üê GI√Ä Notion-ready (‚ñ∂, TAB, placeholders)
2a. CALLOUT (1-2 min) ‚Üê str_replace in pagina salvata
3a. ELEVATOR PITCH (2-3 min)
3b. PROPRIET√Ä + VALUTAZIONE (2-3 min)
4a. ANKI CORE (5-8 min) ‚Üê max 25 carte, output .txt
4b. DIAGRAMMA (1-2 min) ‚Üê str_replace in pagina salvata
5.  PUBBLICAZIONE NOTION (2-3 min) ‚Üê Upload pagina ready + propriet√†
    5a. Upload content (1 min) ‚Üê ZERO rigenerazione
    5b. Popolamento propriet√† (1-2 min) ‚Üê DATABASE UNIFICATO
5c. LINK AUTOMATICO (3-5 min) ‚Üê Opzionale
```

**Tempo totale ottimizzato**: ~55-60 min (da ~70 min v2.5)

---

## MODALIT√Ä ONESHOT (default)

**Comportamento automatico**: Dopo ogni fase completata, auto-avanza alla successiva senza conferme

**Flusso Interno**:

1. **Inizio workflow**: Inizializza scratchpad
   ```python
   workflow_state = reset_scratchpad()
   workflow_state["workflow_type"] = "completo"
   workflow_state["mode"] = "oneshot"  # default
   workflow_state["fase_corrente"] = "1a"
   ```

2. **Prima di ogni fase**: Check prerequisiti
   ```python
   can_proceed = check_prerequisites(fase_target)
   if not can_proceed["can_proceed"]:
       STOP e mostra errore
   ```

3. **Durante fase**: Esegui operazioni + salva in scratchpad

4. **Dopo fase completata**:
   ```python
   update_scratchpad_after_phase(fase_id, output_data)
   workflow_state["fasi_completate"].append(fase_id)

   if workflow_state["mode"] == "oneshot":
       next_fase = get_next_phase(fase_id, workflow_type)
       if next_fase:
           print(f"[ONESHOT] Auto-avanzamento: {next_fase}")
           execute_phase(next_fase)
       else:
           print("[WORKFLOW COMPLETATO]")
           show_final_summary()
   else:  # manual mode
       print("[CONTINUA] | [MODIFICA] | [FERMA]")
   ```

**Ordine esecuzione fasi** (workflow completo):
```
1a ‚Üí 1b ‚Üí [2a, 3a, 3b, 4a, 4b in parallelo]* ‚Üí 5 (5a ‚Üí 5b) ‚Üí 5c

* Fasi parallele: esegui in sequenza ma senza dipendenze tra loro
  Ordine suggerito: 2a, 4b (modificano pagina), poi 3a, 3b, 4a (indipendenti)
```

**Output utente durante oneshot**:
```
[Fase 1a] ‚úì Completata
[ONESHOT] Auto-avanzamento: 1b

[Fase 1b] Generazione pagina: H2 3/5 completati
[Fase 1b] ‚úì Completata
[ONESHOT] Auto-avanzamento: 2a

[Fase 2a] ‚úì Callout inseriti: 4 (‚ö†Ô∏è2 | üí°1 | ‚≠ê1)
[ONESHOT] Auto-avanzamento: 3a

[Fase 3a] ‚úì Completata (185 parole)
[ONESHOT] Auto-avanzamento: 3b

[Fase 3b] ‚úì Propriet√† estratte
[ONESHOT] Auto-avanzamento: 4a

[Fase 4a] ‚úì Deck Anki generato: anki_deck.txt (23 carte CORE)
[ONESHOT] Auto-avanzamento: 4b

[Fase 4b] ‚úì Diagramma inserito: flowchart (10 nodi)
[ONESHOT] Auto-avanzamento: 5

[Fase 5 Step A] ‚úì Pagina aggiornata: [URL]
[Fase 5 Step B] Termini processati: 12/12 (cached: 3, created: 9)
[Fase 5 Step B] ‚úì Propriet√† aggiornate
[ONESHOT] Auto-avanzamento: 5c

[Fase 5c] ‚úì Collegamenti creati: 3
[WORKFLOW COMPLETATO]

[mostra SUMMARY FINALE]
```

**Modalit√† manual** (se `manual_mode=true`):
- Dopo ogni fase: pausa e chiedi conferma
- Utente deve digitare `continua` per avanzare
- Utile per: debugging, workflow parziali, review intermedi

**Stop automatico oneshot**:
- Errore validation
- Errore API (dopo retry esauriti)
- Comando esplicito `ferma`

---

### FASE 1a: TRACCIA

**Obiettivo**: Estrarre struttura H2/H3 ottimale per scrittura

**Regole Specifiche Fase**:
- Se scope macro (es. "Patologie cornea"): copri TUTTE proporzionalmente alla fonte (patologia A = 40% sbobina -> 40% pagina)
- Se `focus=X` specificato: zoom su quella sezione

**Input**: Sbobina allegata

**Output**: Stampa SOLO la traccia markdown, zero metadati o delimitatori.

```markdown
# [Titolo Argomento]

## [H2 - Pilastro 1]
-> Note sviluppo: [1-2 frasi guida cosa includere]

### [H3 - Sottopunto 1.1] (opzionale)
-> [Breve nota]

## [H2 - Pilastro 2]
-> Note sviluppo: [...]

[...continua fino a 4-6 H2]
```

**Post-output** (interno):
Verifica H2 in range 4-6, offri -> [CONTINUA] | [MODIFICA] | [FERMA]

---

### FASE 1b: PAGINA NOTION (Notion-ready markdown)

**Obiettivo**: Sviluppare contenuto completo Notion-ready seguendo traccia

**IMPORTANTE - Formato Notion-ready**:
- Output GI√Ä formattato per import diretto Notion
- NO rigenerazione in Fase 5 (solo str_replace per callout/diagramma)
- Markdown salvato in `workflow_state["outputs"]["pagina_notion_md"]`

**Regole Specifiche Fase**:
- **Applica regole CCI** (vedi Custom Instructions)
- **Struttura**: Usa esattamente H2/H3 della traccia
- **Toggle headers**: Aggiungi ‚ñ∂ prima di ogni ## (H2) e ### (H3)
- **Indentazione Notion** (CRITICAL - formato API):
  - **1 livello sotto H2**: 2 spazi iniziali
  - **2 livelli sotto H3**: 4 spazi iniziali
  - **NO TAB** (incompatibile con Notion import)
- **Callout inline esistenti**: 0-2 per sezione H2 (solo alert critici immediati, chiarimenti)
  ```markdown
  <callout color="gray_bg">
  **[Termine]**: [definizione <=90 parole]
  </callout>
  ```
- **Placeholder callout critici**: Inserisci dopo ogni H2 per callout Fase 2a
  ```markdown
  <!-- CALLOUT_PLACEHOLDER_H2_1 -->
  <!-- CALLOUT_PLACEHOLDER_H2_2 -->
  <!-- etc -->
  ```
- **Placeholder diagramma**: Inserisci prima di "## Perle del professore" (o alla fine)
  ```markdown
  <!-- DIAGRAMMA_PLACEHOLDER -->
  ```
- **Domande integrate**: posiziona dopo blocchi, formato `**Domanda clinica?**`
- **Validazione incrementale**: applica auto-check CCI dopo ogni H2

**Progress Indicator** (mostra durante generazione):
```
[Fase 1b] Generazione pagina: H2 [N]/[TOT] completati
```

**Esempio**:
```
[Fase 1b] Generazione pagina: H2 2/5 completati
[Auto-check CCI H2.2] ‚úì PASS
```

**Sviluppo Contenuto per Tipologia**:

**Patologia**: Definizione + epidemiologia -> Fisiopatologia -> Quadro clinico -> Diagnosi (criteri + DD) -> Terapia + follow-up -> Prognosi/Complicanze

**Farmaco**: Classe + meccanismo -> Indicazioni + posologia (solo se in fonte) -> Farmacocinetica -> Effetti avversi -> Controindicazioni -> Interazioni

**Procedura**: Indicazioni + razionale -> Preparazione + materiali -> Steps -> Complicanze + management -> Criteri successo

**Formato Output Esempio** (INDENTAZIONE CON SPAZI):

```markdown
# [Titolo Argomento]

‚ñ∂## [H2 - Pilastro 1]

  [Contenuto paragrafo 1 con main message...]

  <!-- CALLOUT_PLACEHOLDER_H2_1 -->

  ‚ñ∂### [H3 - Sottosezione 1.1]

    [Contenuto sotto H3...]

  [Contenuto paragrafo 2...]

  **Domanda clinica rilevante?**

‚ñ∂## [H2 - Pilastro 2]

  [Contenuto...]

  <!-- CALLOUT_PLACEHOLDER_H2_2 -->

[...continua per tutti H2]

<!-- DIAGRAMMA_PLACEHOLDER -->

‚ñ∂## Perle del professore

  [Se presenti in fonte...]
```

**Output**: NON stampare in chat. Salvare SOLO in memoria.

**Comunicazione chat** (unico messaggio):
```
[Fase 1b] ‚úì Completata ([N] parole, [M] H2)
```

**Post-output** (interno):
- Salva in `workflow_state["outputs"]["pagina_notion_md"]`
- Estrai lista H2 per conteggio
- Esegui CCI Quick Check (main message, frasi ‚â§18, numeri con unit√†)
- Se fail ‚â•2: autocorreggi internamente
- Update scratchpad: fase "1b" completata
- Se oneshot: auto-avanza a fase successiva (2a, 3a, 3b, 4a, 4b paralleli)
- Se manual: offri -> [CONTINUA] | [MODIFICA] | [FERMA]

---

### FASE 2a: CALLOUT (str_replace in pagina)

**Obiettivo**: Generare e inserire 3-5 callout clinici critici nella pagina Notion salvata

**IMPORTANTE - Nuovo flusso str_replace**:
- NON generare lista separata
- Genera callout E inseriscili direttamente in `workflow_state["outputs"]["pagina_notion_md"]`
- Usa str_replace per sostituire placeholder `<!-- CALLOUT_PLACEHOLDER_H2_N -->`
- Output chat: SOLO conferma inserimento

**Regole Specifiche Fase**:
- **Numero**: 3-5 callout totali (vedi limiti cognitivi CI)
- **Distribuzione**: Max 1-2 callout per H2 (usa placeholder disponibili)
- **Priorita selezione**:
  1. Controindicazioni assolute / salvavita (sempre)
  2. Red flags diagnostiche critiche
  3. Errori comuni da evitare
  4. Meccanismi fisiopatologici chiave (max 1-2)
  5. Differenze diagnostiche cruciali (se comparativo)

**Sistema Classificazione** (INDENTAZIONE 2 SPAZI):
- [!] **Avvertenza**: Critici per sicurezza, controindicazioni assolute, red flags diagnostiche
  ‚Üí Formato:
  ```markdown
  <callout icon="/icons/warning_red.svg" color="red_bg">
  <span color="red">[testo]</span>
  </callout>
  ```
- [i] **Principio**: Meccanismi fisiopatologici, ragionamento "come/perch√©"
  ‚Üí Formato:
  ```markdown
  <callout icon="/icons/light-bulb_blue.svg" color="blue_bg">
  <span color="blue">[testo]</span>
  </callout>
  ```
- [*] **High-Yield**: Fatti nozionistici (definizioni, criteri, terapie prima linea)
  ‚Üí Formato:
  ```markdown
  <callout icon="/icons/star_green.svg" color="green_bg">
  <span color="green">[testo]</span>
  </callout>
  ```

**Criteri Callout**:
- Frase singola auto-esplicativa (no contesto aggiuntivo richiesto)
- Max 2 item se inevitabile
- Applica anti-confusori se necessario (vedi Fase 4a pattern)

**Processo Interno** (NON mostrare a utente):

1. **Analizza pagina salvata**: Identifica H2 e placeholder disponibili
2. **Genera 3-5 callout**: Associa ogni callout a H2 specifico
3. **Per ogni callout** (INDENTAZIONE 2 SPAZI):
   ```python
   # Identifica placeholder target
   placeholder = f"<!-- CALLOUT_PLACEHOLDER_H2_{N} -->"

   # Formatta callout Notion con 2 spazi per indentazione
   if tipo == "avvertenza":
       callout_md = f'  <callout icon="/icons/warning_red.svg" color="red_bg">\n  <span color="red">{testo}</span>\n  </callout>'
   elif tipo == "principio":
       callout_md = f'  <callout icon="/icons/light-bulb_blue.svg" color="blue_bg">\n  <span color="blue">{testo}</span>\n  </callout>'
   elif tipo == "high_yield":
       callout_md = f'  <callout icon="/icons/star_green.svg" color="green_bg">\n  <span color="green">{testo}</span>\n  </callout>'

   # Esegui str_replace
   pagina_md = workflow_state["outputs"]["pagina_notion_md"]
   pagina_md_updated = pagina_md.replace(placeholder, callout_md)
   workflow_state["outputs"]["pagina_notion_md"] = pagina_md_updated
   ```

4. **Rimuovi placeholder non usati**: Sostituisci con stringa vuota
5. **Update scratchpad**: `workflow_state["outputs"]["callout_posizionati"] = True`

**Output** (unico messaggio chat):

```
‚úì Callout inseriti: N (‚ö†Ô∏è[N] | üí°[N] | ‚≠ê[N])
```

**Post-output** (interno):
- Verifica 3-5 callout totali
- Verifica distribuzione tipologie
- Verifica str_replace riusciti (no placeholder rimasti eccetto non usati)
- Update scratchpad: fase "2a" completata
- Se oneshot: auto-avanza (continua con altre fasi parallele o successiva)
- Se manual: offri -> [CONTINUA] | [MODIFICA] | [FERMA]

---

### FASE 3a: ELEVATOR PITCH

**Obiettivo**: Sintesi 170-200 parole per recall rapido

**Regole Specifiche Fase**:
- **Lunghezza**: Esattamente 170-200 parole (conteggio automatico strict)
- **Modalit√† auto-select**:
  - **Singola** (1 argomento): Cos'√® + Perch√© importante + Come gestire
  - **Comparativa** (>=2 argomenti o patologie A vs B): Cosa distingue + Quando scegliere A vs B

**Struttura Singola**: Opening (1 frase def) -> Core (2-3 frasi fisiopat/epidemio) -> Clinica (2 frasi) -> Diagnosi (1-2 frasi criteri) -> Management (2 frasi tx first-line) -> Closing (1 frase prognosi/take-home)

**Struttura Comparativa**: Opening -> Elemento differenziante 1-3 (eziologia, clinica, terapia) -> Closing (quando scegliere A vs B)

**Stile**: Applica CCI (voce attiva, frasi 12-15 parole) + **Grassetto**: UNA sola frase con mossa decisiva

**Output**: Stampa SOLO il paragrafo pitch (170-200 parole), zero metadati.

```markdown
[Paragrafo unico 170-200 parole con una frase in grassetto per mossa decisiva]
```

**Post-output** (interno):

**Validazione automatica strict**:
```
Conteggio parole: [N]
Status: [PASS se 170-200 | FAIL se fuori range]
Frasi totali: [N]
Frasi >15 parole: [N]
Grassetto presente: [S√å/NO]
```

**Se FAIL lunghezza**:
- <170 parole: espandi con dettagli clinici rilevanti
- >200 parole: riduci eliminando ridondanze (priorit√†: fisiopat teorica, epidemio non critica)
- Ricontrolla dopo correzione (max 2 iterazioni)

**Se >30% frasi >15 parole**: riformula pi√π conciso

Offri -> [CONTINUA] | [MODIFICA] | [FERMA]

---

### FASE 3b: PROPRIET√Ä + VALUTAZIONE AUTOMATICA

**Obiettivo**: Estrarre 2-3 termini iconici per propriet√† database + calcolare complessit√† e tempo studio

**Thinking Process** (interno):
1. Quali termini distinguono questo da altri simili?
2. Livello ottimale astrazione? (es. "Opportunisti" > "Infezioni opportunistiche")
3. Acronimo standard disponibile? (es. "TC" > "Tomografia Computerizzata")

**Regole Specifiche Fase**:
- Concetti distillati (no frasi complete)
- Evita ridondanza (no sinonimi nella stessa categoria)
- Massimo 3 termini per categoria (se fonte ne supporta 4-5, scegli i 3 pi√π distintivi)

**Categorie Propriet√†**:
1. **Eziologia**: Cause o categorie patogenetiche (es. "Autoimmune", "Virale")
2. **Clinica**: Sintomi/segni iconici (es. "Dolore neuropatico", "Diplopia")
3. **Diagnosi**: Criteri gold standard (es. "Criteri McDonald", "Biopsia")
4. **Terapia**: Farmaci/interventi prima linea (es. "Corticosteroidi", "Ablazione")

**Valutazione Automatica**:

**A. Calcolo Complessit√†**

Score basato su:
- **Struttura**: H2 (1 punto), H3 (0.5 punto), Domande integrate (0.5 punto)
- **Contenuto**: Callout inline (0.5 punto), Chiarimenti (0.3 punto)
- **Terminologia**: Termini totali estratti in propriet√† / 3

Score finale:
- 0-2 punti ‚Üí **Semplice**
- 3-4 punti ‚Üí **Media**
- ‚â•5 punti ‚Üí **Complessa**

**B. Calcolo Tempo Studio Stimato**

Formula:
```
Tempo = (H2 √ó 2.5) + (H3 √ó 1.5) + (Callout √ó 1) + (Domande √ó 0.5)
Arrotonda a multiplo di 5 pi√π vicino
```

**Output**: Stampa SOLO le 4 liste termini + valutazione automatica, zero delimitatori.

```markdown
**Eziologia**: [termine1, termine2, termine3]
**Clinica**: [termine1, termine2, termine3]
**Diagnosi**: [termine1, termine2, termine3]
**Terapia**: [termine1, termine2, termine3]

**Complessit√†**: [Semplice/Media/Complessa]
**Tempo studio stimato**: [N] minuti
```

**Post-output** (interno):
Offri -> [CONTINUA] | [MODIFICA] | [FERMA]

---

### FASE 4a: ANKI CORE

**Obiettivo**: Max 25 flashcard atomiche high-yield con singola cloze per spaced repetition

**Regole Specifiche Fase** (CRITICAL):
- **Numero**: Max 25 carte CORE (vedi limiti cognitivi CI)
- **Formato**: **SOLO Cloze deletion con c1** (mai c2, c3, c4...)
- **Atomicit√†**: 1 concetto/card (NO listing cards tipo "cause: A, B, C")
- **Testabilit√†**: Stem rispondibile anche a cloze chiusa
- **High-yield**: SOLO informazioni essenziali (definizioni, criteri diagnostici must-know, terapie first-line, red flags, meccanismi chiave)

**Esempi Carte Buone vs Cattive**:

‚ùå **MALE**: "Le complicanze del diabete includono {{c1::nefropatia, retinopatia, neuropatia}}."
‚Üí Listing card, troppo ampia, non atomica

‚úÖ **BENE**: "La principale causa di cecit√† nel diabete tipo 2 √® {{c1::retinopatia diabetica}}."
‚Üí Atomica, clinicamente rilevante, stem univoco

‚ùå **MALE**: "Il farmaco di prima linea √® {{c1::metformina}}."
‚Üí Ambigua (per cosa? in che contesto?)

‚úÖ **BENE**: "Nel diabete tipo 2 senza insufficienza renale, il farmaco di prima linea √® {{c1::metformina}}."
‚Üí Stem univoco con micro-cue contestuale

‚ùå **MALE**: "I criteri diagnostici sono {{c1::A, B, C}}."
‚Üí Lista lunga, difficile recall

‚úÖ **BENE**: "Per diagnosticare febbre reumatica servono 2 criteri {{c1::maggiori}} O 1 maggiore + 2 minori."
‚Üí Testa logica decisionale, non mera lista

**Anti-confusori automatici**: Aggiungere cue contestuali per evitare interferenza tra carte simili

**Pattern da applicare sistematicamente**:

1. **Et√†/popolazione**: specifica sempre se differisce da default
   - "nel *neonato*" (se info pediatrica)
   - "nell'*adulto* >65 anni" (se geriatria)
   - Default: adulto 18-65 (non serve specificare)

2. **Temporalit√†**: distingui fase/durata
   - "nella fase *acuta* (<72h)" vs "nella fase *cronica* (>3 mesi)"
   - "in *prima dose*" vs "a regime"

3. **Gravit√†/tipo**: evita ambiguit√†
   - "nell'asma *intermittente*" vs "nell'asma *persistente grave*"
   - "nel diabete *tipo 1*" vs "nel diabete *tipo 2*"

4. **Localizzazione anatomica**: specifica se cruciale
   - "nell'ictus *emisfero dominante*"
   - "nella lesione *emisfero sx*"

5. **Contesto clinico**: micro-cue situazionale
   - "in *assenza di insufficienza renale*"
   - "se *non controindicazioni assolute*"
   - "in *paziente non trattato*"

**Applicazione**: Scansiona ogni carta e aggiungi cue se:
- Argomento ha varianti (es. farmaco con dosi diverse per et√†)
- Concetto compare in pi√π contesti (es. criterio valido solo in acuto)
- Rischio confusione con carte precedenti (stesso termine, contesto diverso)

**Output**: Genera file **anki_deck.txt** con una carta per linea (zero intestazioni, delimitatori, o numerazione).

**Formato file**:
```
[Stem con {{c1::risposta}}]
[Stem con {{c1::risposta}}]
[Stem con {{c1::risposta}}]
[...max 25 linee]
```

**Comunicazione chat**: Stampa SOLO messaggio conferma:
```
‚úì Deck Anki generato: anki_deck.txt (N carte CORE)
```

**Post-output** (interno):
- Verifica ogni carta: stem univoco? Singola c1? No duplicati?
- Check range ‚â§25 totale
- Offri -> [CONTINUA] | [MODIFICA] | [FERMA]

---

### FASE 4b: DIAGRAMMA (str_replace in pagina)

**Obiettivo**: Generare e inserire diagramma clinico Mermaid nella pagina Notion salvata

**IMPORTANTE - Nuovo flusso str_replace**:
- NON stampare diagramma in chat
- Genera diagramma E inseriscilo direttamente in `workflow_state["outputs"]["pagina_notion_md"]`
- Usa str_replace per sostituire placeholder `<!-- DIAGRAMMA_PLACEHOLDER -->`
- Output chat: SOLO conferma inserimento

**Regole Specifiche Fase**:
- **Tipo**: Auto-select basato su contenuto
  - Flowchart: Algoritmi diagnostici/terapeutici
  - Timeline: Decorso patologia o marcia atopica
  - Mindmap: Collegamenti fisiopatologici
  - Sankey: Progressione complicanze
- **Stile**: Palette neutra (bianco #FFFFFF, ghiaccio #F8FAFC, grigi #64748B), accento #00E0CC solo per step critici
- **Nodi**: Max 10-12, labels concisi (<=5 parole)
- **Leggibilit√†**: Font grande, contrasto 4.5:1

**Processo Interno** (NON mostrare a utente):

1. **Genera diagramma**: Crea codice mermaid appropriato
2. **Formatta per Notion**:
   ```python
   diagramma_md = f"```mermaid\n{codice_mermaid}\n```"
   ```
3. **Esegui str_replace**:
   ```python
   placeholder = "<!-- DIAGRAMMA_PLACEHOLDER -->"
   pagina_md = workflow_state["outputs"]["pagina_notion_md"]
   pagina_md_updated = pagina_md.replace(placeholder, diagramma_md)
   workflow_state["outputs"]["pagina_notion_md"] = pagina_md_updated
   ```
4. **Update scratchpad**: `workflow_state["outputs"]["diagramma_inserito"] = True`

**Output** (unico messaggio chat):

```
‚úì Diagramma inserito: [tipo] ([N] nodi)
```

**Post-output** (interno):
- Verifica tipo appropriato
- Verifica max 10-12 nodi
- Verifica str_replace riuscito (no placeholder rimasto)
- Update scratchpad: fase "4b" completata
- Se oneshot: auto-avanza a Fase 5
- Se manual: offri -> [CONTINUA] | [MODIFICA] | [FERMA]

---

### FASE 5: PUBBLICAZIONE NOTION (UPDATE pagina esistente)

**Obiettivo**: Aggiornare pagina esistente in database Argomenti con contenuto formattato + propriet√†

**IMPORTANTE**: La pagina esiste GI√Ä (creata a inizio esame). Usare UPDATE, non CREATE.

**Prerequisiti** (verificati da scratchpad):
- Fase 1b completata: `workflow_state["outputs"]["pagina_notion_md"]` non vuota
- Fase 2a completata: `workflow_state["outputs"]["callout_posizionati"]` = True
- Fase 3a completata: `workflow_state["outputs"]["elevator_pitch"]` non vuoto
- Fase 3b completata: `workflow_state["outputs"]["proprieta"]` compilato
- Fase 4a completata: `workflow_state["outputs"]["anki_deck_txt_generated"]` = True
- Fase 4b completata: `workflow_state["outputs"]["diagramma_inserito"]` = True

**PRE-FLIGHT VALIDATION** (interno, prima di API calls):

Esegui controlli rigorosi usando scratchpad:
```python
# Verifica prerequisiti completati
if "1b" not in workflow_state["fasi_completate"]:
    ERROR: "Pagina Notion non generata"

pagina_md = workflow_state["outputs"]["pagina_notion_md"]

# Verifica formato
‚úì Titolo: non vuoto, ‚â§100 caratteri
‚úì H2: range 4-6, tutti hanno ‚ñ∂
‚úì H3: tutti hanno ‚ñ∂
‚úì Callout: 3-5 totali inseriti, tutti hanno icon + color validi
‚úì Pitch: esattamente 170-200 parole
‚úì Complessit√†: in ["Semplice", "Media", "Complessa"]
‚úì Tempo studio: intero positivo, multiplo di 5
‚úì Termini propriet√†: 2-3 per categoria, non vuoti
‚úì Diagramma: blocco mermaid inserito (cerca ```mermaid in pagina_md)
‚úì anki_deck.txt: esiste, ‚â§25 linee, ogni linea ha {{c1::...}}
‚úì NO placeholder rimasti: cerca <!-- in pagina_md (se trovati ‚Üí ERROR)
```

**Se validation fail**: STOP e segnala errore specifico prima di chiamare API.

**Strategia 2 Step**:
- **Step A (veloce)**: Import content completo ‚Üí utente pu√≤ iniziare a studiare
- **Step B (veloce)**: Popolamento propriet√† ‚Üí DATABASE UNIFICATO VOCI

---

**STEP A: UPLOAD CONTENT** (~1-2 min)

**A1. Ricerca Pagina Esistente**

Usa `notion-search` con:
```json
{
  "query": "[workflow_state['outputs']['titolo_argomento']]",
  "query_type": "internal",
  "data_source_url": "collection://1b528251-9c2c-8065-a61e-000bfdfab7c7"
}
```

Se non trovata: ERRORE e chiedi conferma titolo esatto.
Se trovata: salva in `workflow_state["outputs"]["notion_page_id"]` per update.

**A2. Upload Content + Pitch** (ZERO rigenerazione)

**Usa markdown GI√Ä pronto da scratchpad**:
```python
pagina_md_ready = workflow_state["outputs"]["pagina_notion_md"]
# Gi√† contiene: ‚ñ∂ headers, TAB indentation, callout inseriti, diagramma inserito
```

Usa `notion-update-page` con:
```json
{
  "page_id": "[workflow_state['outputs']['notion_page_id']]",
  "command": "replace_content",
  "new_str": "[workflow_state['outputs']['pagina_notion_md']]"
}
```

Poi aggiorna propriet√† basilari:
```json
{
  "page_id": "[workflow_state['outputs']['notion_page_id']]",
  "command": "update_properties",
  "properties": {
    "Pitch": "[workflow_state['outputs']['elevator_pitch']]",
    "Complessit√†": "[workflow_state['outputs']['proprieta']['complessita']]",
    "Tempo studio stimato": [workflow_state['outputs']['proprieta']['tempo_studio']],
    "Status argomento": "In corso"
  }
}
```

**Output Step A**: Stampa SOLO link pagina, zero metadati verbose.

```
‚úì Pagina aggiornata: [URL Notion]
```

**Post-output interno**:
- Update scratchpad: `workflow_state["outputs"]["notion_published"]` = True (parziale, manca Step B)
- Continua automaticamente a Step B (non chiedere conferma)

---

**STEP B: POPOLAMENTO PROPRIET√Ä** (~1-2 min) - DATABASE UNIFICATO VOCI

**Progress Indicator** (mostra durante elaborazione):
```
[Fase 5 Step B] Termini processati: [N]/[TOT]
```

**Esempio**:
```
[Fase 5 Step B] Termini processati: 5/12 (cached: 2, created: 3)
```

**B1. Gestione Relazione Unificata "Voci"**

**Database "Voci" (Unificato)**:
- Database ID: `290282519c2c801ea214d30b803c78f8`
- Data Source: `collection://29028251-9c2c-8024-bd71-000bcc303592`
- Property "Categoria": multi_select con opzioni ["Eziologia", "Clinica", "Diagnosi", "Terapia"]

**Processo BATCH Ottimizzato** (CRITICAL - previene blocchi):

**Fase 1: BATCH SEARCH** (tutti termini insieme)

```python
# Estrai TUTTI i termini da workflow_state
tutti_termini = []
for cat in ["eziologia", "clinica", "diagnosi", "terapia"]:
    for termine in workflow_state["outputs"]["proprieta"][cat]:
        tutti_termini.append({"termine": termine, "categoria": cat.capitalize()})

# BATCH SEARCH in gruppi di 10 (evita overwhelm)
batch_size = 10
termini_trovati = {}  # {termine: URL}
termini_da_creare = []

for i in range(0, len(tutti_termini), batch_size):
    batch = tutti_termini[i:i+batch_size]

    # Search batch (singola query per termine, ma in rapida successione)
    for item in batch:
        # Check cache PRIMA di search
        if item["termine"] in cache_termini:
            termini_trovati[item["termine"]] = cache_termini[item["termine"]]
            continue

        # Search
        result = notion-search(item["termine"], db_voci)
        if result:
            url_pulito = result["url"].replace("{{", "").replace("}}", "")
            termini_trovati[item["termine"]] = url_pulito
            cache_termini[item["termine"]] = url_pulito  # Aggiungi a cache
        else:
            termini_da_creare.append(item)

    # Pausa 500ms tra batch per rate limiting
    if i + batch_size < len(tutti_termini):
        sleep(0.5)
```

**Fase 2: BATCH CREATE** (tutti mancanti insieme)

```python
if termini_da_creare:
    # Crea TUTTI i termini mancanti in UNA SOLA chiamata
    pages_to_create = []
    for item in termini_da_creare:
        pages_to_create.append({
            "properties": {
                "Name": item["termine"],
                "Categoria": f'["{item["categoria"]}"]'  # JSON string array
            }
        })

    # BATCH CREATE (singola API call)
    result = notion-create-pages({
        "parent": {"data_source_id": "29028251-9c2c-8024-bd71-000bcc303592"},
        "pages": pages_to_create
    })

    # Estrai URL creati
    for i, created_page in enumerate(result["pages"]):
        termine = termini_da_creare[i]["termine"]
        url_pulito = created_page["url"].replace("{{", "").replace("}}", "")
        termini_trovati[termine] = url_pulito
        cache_termini[termine] = url_pulito  # Aggiungi a cache
```

**Fase 3: Costruzione relazione unificata**

```python
# Colleziona TUTTI gli URL in lista unica
lista_url = list(termini_trovati.values())

# Converti in stringa JSON
relazione_voci_json = json.dumps(lista_url)  # ‚Üí "[\"url1\", \"url2\", ...]"
```

**Progress Indicator durante processing**:
```
[Fase 5 Step B] Search batch 1/2 (10 termini)
[Fase 5 Step B] Creazione batch: 5 nuove voci
[Fase 5 Step B] ‚úì Termini processati: 12/12 (cached: 3, created: 5, found: 4)
```

**BENEFICI**:
- Riduzione 80% chiamate API (batch create vs individuale)
- Cache evita ricerche duplicate
- Pause controllate evitano rate limit
- Progress visibile per debug

**B2. Update Propriet√†**

Usa `notion-update-page` con la propriet√† unificata "Voci":
```json
{
  "page_id": "[page_id]",
  "command": "update_properties",
  "properties": {
    "Voci": "[\"URL1\", \"URL2\", \"URL3\", ...]",
    "Pitch": "[elevator_pitch]",
    "Complessit√†": "[Semplice/Media/Complessa]",
    "Tempo studio stimato": [numero_minuti]
  }
}
```

**FORMATO RELAZIONI - CRITICO:**

‚úÖ **CORRETTO**:
```json
"Voci": "[\"https://notion.so/page1\", \"https://notion.so/page2\", \"https://notion.so/page3\"]"
```

‚ùå **ERRATO**:
```json
"Voci": ["https://notion.so/page1", "https://notion.so/page2"]
"Voci": ["{{https://notion.so/page1}}"]
```

Le doppie graffe `{{...}}` sono **solo nell'output** di Notion (quando leggi), **mai nell'input** (quando scrivi).

**Output Step B**: Zero output verbose, solo conferma.

```
‚úì Propriet√† aggiornate
```

**Post-output interno**: 
- Verifica tutte propriet√† aggiornate
- Offri -> [CONTINUA per LINK AUTOMATICO] | [FERMA]

**Note Tecniche Fase 5**:

**Gestione Errori & Retry Logic**:
- **API timeout**: Retry max 3 volte con backoff (1s, 2s, 4s)
- **Rate limit (429)**: Pausa automatica 1s e retry (max 3)
- **Not found (404)**: Zero retry, segnala errore immediatamente
- **Server error (500+)**: Retry max 2 volte con backoff 2s
- **Network error**: Retry max 3 volte con backoff 1s

**Logging interno** (non mostrare a utente):
```
[Retry 1/3] notion-search fallito (429) ‚Üí pausa 1s
[Retry 2/3] notion-update-page fallito (timeout) ‚Üí pausa 2s
[SUCCESS] dopo 2 retry
```

**Cache Termini Voci** (sessione corrente):
- Mantieni dizionario `{termine: URL}` in memoria durante workflow
- Prima di `notion-search` per termine: check cache
- Se hit: usa URL cached (risparmia 1 API call)
- Aggiungi a cache dopo ogni create/search riuscito
- Reset cache a inizio nuovo workflow

**Rate Limiting**:
- Max 3 req/sec (inserisci pausa 350ms tra chiamate consecutive)
- Batch operations quando possibile

**Validazione pre-update** (spostata in PRE-FLIGHT sopra):
  - ‚úì Tutti H2/H3 hanno ‚ñ∂
  - ‚úì Callout hanno color e icon validi (/icons/...)
  - ‚úì Pitch esattamente 170-200 parole
  - ‚úì Content correttamente indentato (TAB)
  - ‚úì **Relazioni in formato stringa JSON**
  - ‚úì **Complessit√† in ["Semplice", "Media", "Complessa"]**
  - ‚úì **Tempo studio √® numero intero positivo**
  - ‚úì **Categoria in Voci √® JSON string array** (es: `["Eziologia"]`)
  - ‚úì **Relazione bidirezionale**: "Argomento" in Voci viene popolato automaticamente

**Flusso costruzione relazione unificata**:
1. Cerca termine in Voci ‚Üí ottieni URL `{{https://...}}`
2. Pulisci: rimuovi `{{` e `}}` ‚Üí `https://...`
3. Aggiungi a lista unica: `["url1", "url2", "url3", ...]` (tutti i termini)
4. Converti in stringa JSON: `"[\"url1\", \"url2\", \"url3\", ...]"`
5. Passa a properties: `"Voci": stringa_json`

---

### FASE 5c: LINK AUTOMATICO ARGOMENTI CORRELATI

**Obiettivo**: Suggerire collegamenti tra argomenti basati su overlap propriet√†

**Trigger**: Automatico dopo Fase 5, o comando `link auto [argomento]`

**Logica Matching**:

**Step 1: Ricerca Candidati**

Usa `notion-search` su database Argomenti con:
- `query_type`: "internal"
- `data_source_url`: "collection://1b528251-9c2c-8065-a61e-000bfdfab7c7"
- Filtra risultati dove `Argomento primario = YES`
- Escludi: argomento corrente

**Step 2: Calcolo Match Score**

Per ogni candidato, calcola overlap voci:

```python
# Pseudocodice
score = 0
matches = {
    "Eziologia": [],
    "Clinica": [],
    "Diagnosi": [],
    "Terapia": []
}

# Recupera tutte le voci per entrambi gli argomenti
voci_corrente = fetch_voci_argomento(argomento_corrente)
voci_candidato = fetch_voci_argomento(argomento_candidato)

# Per ogni categoria, filtra voci per propriet√† "Categoria"
for categoria in ["Eziologia", "Clinica", "Diagnosi", "Terapia"]:
    # Filtra voci per categoria
    voci_corrente_cat = [v for v in voci_corrente if categoria in v.Categoria]
    voci_candidato_cat = [v for v in voci_candidato if categoria in v.Categoria]
    
    # Estrai nomi delle voci
    termini_corrente = set([v.Name for v in voci_corrente_cat])
    termini_candidato = set([v.Name for v in voci_candidato_cat])
    
    # Calcola overlap
    overlap = termini_corrente & termini_candidato
    if overlap:
        score += len(overlap)
        matches[categoria] = list(overlap)

# Soglia minima: score >= 2
```

**Note implementazione**:
- Fetch della relazione "Voci" per entrambi gli argomenti
- Per ogni voce, verifica propriet√† "Categoria" (multiselect)
- Una voce pu√≤ apparire in pi√π categorie se ha multiple categorie assegnate
- Match basato sul nome della voce, non sull'URL

**Step 3: Ranking Candidati**

Ordina per score decrescente, mostra top 5 (se ‚â• 2 match)

**Output Format**:
```markdown
[LINK] Argomenti correlati trovati

1. **[Argomento 1]** - Score: 5
   - Eziologia: termine1, termine2
   - Clinica: termine3

2. **[Argomento 2]** - Score: 3
   - Diagnosi: termine1, termine2, termine3

[AUTO] Crea tutti | [SELECT] Scegli | [SKIP] Salta
```

**Step 4a: Creazione Automatica** (se AUTO)

Per ogni candidato con score ‚â• 2:

1. Crea pagina collegamento nel database "Argomenti":
   ```json
   {
     "Nome": "Link: [ArgCorrente] ‚Üî [Candidato]",
     "Argomento primario": "__NO__",
     "Tipo": "Collegamento",
     "Status argomento": "Attivo"
   }
   ```

2. Aggiungi alla propriet√† relazionale "Argomenti correlati":
   - Argomento Corrente: aggiungi URL candidato
   - Argomento Candidato: aggiungi URL argomento corrente

3. Content pagina collegamento:
   ```markdown
   # Link Clinico: [ArgCorrente] ‚Üî [Candidato]
   
   ## Termini Comuni
   
   **Eziologia**: [lista]
   **Clinica**: [lista]
   **Diagnosi**: [lista]
   **Terapia**: [lista]
   
   ## Note
   Link generato automaticamente. Match score: {N}
   ```

**Step 4b: Selezione Manuale** (se SELECT)

```
Inserisci numeri (es. "1,3"):
[Input utente]

Creo collegamenti per selezionati
```

**Output finale**:
```
‚úì Collegamenti creati: [N]

Visualizza pagina: [URL Notion]
```

**Note Tecniche Fase 5c**:
- Rate limiting: Max 3 req/sec
- Cache risultati search
- Gestione bidirezionale link
- Skip automatico se match 0

**Gestione Errori**:
- Se property "Argomenti correlati" non trovata ‚Üí skip con warning
- Se API rate limit ‚Üí pausa 1s e retry (max 3)
- Se match 0 ‚Üí messaggio informativo

---

### WORKFLOW COMPLETO - SUMMARY FINALE

**Obiettivo**: Riepilogo metriche e checklist qualit√† post-workflow

**Quando eseguire**: Automaticamente alla fine Fase 5c (o 5 se skip_link=true)

**Output Summary**:

```markdown
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    WORKFLOW COMPLETO - RIEPILOGO FINALE
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìä METRICHE CONTENUTO
‚îú‚îÄ Traccia H2: [N] pilastri
‚îú‚îÄ Pagina Notion: [N] parole totali
‚îÇ  ‚îú‚îÄ Frasi totali: [N]
‚îÇ  ‚îú‚îÄ Frasi >18 parole: [N] ([X]%)
‚îÇ  ‚îî‚îÄ Media parole/frase: [N.N]
‚îú‚îÄ Callout: [N] (‚ö†Ô∏è[N] | ‚≠ê[N] | üí°[N])
‚îú‚îÄ Domande: [N]
‚îú‚îÄ Chiarimenti: [N]
‚îú‚îÄ Elevator Pitch: [N] parole
‚îî‚îÄ Anki CORE: [N] carte

üîó PROPRIET√Ä & LINKING
‚îú‚îÄ Voci totali: [N] (Eziologia:[N] | Clinica:[N] | Diagnosi:[N] | Terapia:[N])
‚îú‚îÄ Complessit√†: [Semplice/Media/Complessa]
‚îú‚îÄ Tempo studio: [N] min
‚îî‚îÄ Link automatici: [N] argomenti correlati

‚è±Ô∏è  PERFORMANCE
‚îú‚îÄ Tempo totale: [N] min
‚îú‚îÄ API calls: [N] (cached: [N], retry: [N])
‚îî‚îÄ Termini cache hit rate: [X]%

‚úÖ CHECKLIST QUALIT√Ä CCI
‚îú‚îÄ [‚úì/‚úó] Main message in ogni H2
‚îú‚îÄ [‚úì/‚úó] Frasi ‚â§18 parole (‚â•90%)
‚îú‚îÄ [‚úì/‚úó] Numeri con unit√†
‚îú‚îÄ [‚úì/‚úó] Pitch 170-200 parole
‚îú‚îÄ [‚úì/‚úó] Anki ‚â§25 CORE, solo c1
‚îî‚îÄ [‚úì/‚úó] Pre-flight validation PASS

üîó LINK NOTION
‚îî‚îÄ [URL pagina pubblicata]

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
```

**Note**:
- Summary √® SOLO per visibilit√† utente (non salva in file)
- Se checklist ‚â•2 ‚úó ‚Üí segnala warning e suggerisci correzioni
- Metriche performance opzionali se non tracciabili

---

# WORKFLOW ESSENZIALE

## COMANDO: essenziale

**Trigger**: Utente scrive "essenziale" O richiede solo contenuto principale

**Fasi**: 4 (solo output core)
**Tempo totale**: ~25-30 min

**Sequenza**:
```
1a. TRACCIA (5-10 min)
1b. PAGINA NOTION (15-25 min)
3a. ELEVATOR PITCH (2-3 min)
3b. PROPRIET√Ä + VALUTAZIONE (2-3 min)
```

**Output finale**: Pagina Notion + Pitch + Propriet√† (senza callout, anki, diagramma, pubblicazione)

---

# COMANDO PUBBLICAZIONE STANDALONE

## COMANDO: pubblica notion

**Trigger**: Utente ha gi√† tutti gli output e vuole solo pubblicare

**Prerequisito**: Deve avere in chat/progetto:
1. Titolo argomento esatto
2. Contenuto pagina markdown
3. Lista callout
4. Elevator pitch
5. Propriet√† estratte + Complessit√† + Tempo studio
6. File anki_deck.txt
7. Diagramma (opzionale)

**Azione**: Esegui FASE 5 completa (Step A + B: UPDATE pagina esistente)

**Importante**: Cerca pagina esistente per titolo, poi UPDATE (non CREATE)

**Output**: Link pagina aggiornata

---

# GESTIONE MODIFICHE

Se utente chiede modifica output gi√† generato:

1. **Modifica puntuale** (es. "aggiungi section X"):
   - Rigenera SOLO parte richiesta
   - Mantieni resto invariato

2. **Rigenerazione completa** (es. "rifai tutto"):
   - Riparti da fase corrente
   - Usa stesso input

3. **Cambio scope** (es. "focus su diagnosi"):
   - Applica parametro `focus=diagnosi`
   - Rigenera contenuto filtrato

---

# VALIDAZIONE ORCHESTRATOR

**Auto-check prima output** (interno, non stampare):
- [OK] Applico regole CI? (CCI, fonte, stile, limiti cognitivi)
- [OK] Output SOLO contenuto pulito? (zero metadati, delimitatori, checkpoint verbose)
- [OK] Fase 5 usa UPDATE (non CREATE)?
- [OK] Fase 5 usa database Voci unificato correttamente?
- [OK] Property Categoria in Voci √® JSON string array?
- [OK] Fase 5c calcola match score correttamente?
- [OK] Anki: SOLO CORE (max 25), SOLO c1 (mai c2/c3/c4), output .txt con 1 carta/linea?
- [OK] Complessit√† e Tempo studio calcolati in Fase 3b?

Se NO a >=2 -> autocorreggi prima mostrare

---

# PARAMETRI GLOBALI

## Override Limiti

Inserisci PRIMA del comando:

```
n=30              # Override limite Anki CORE (default: max 25)
focus=diagnosi    # Restringe scope a sezione specifica
mode=comparativo  # Forza modalit√† confronto A vs B
skip_link=true    # Salta Fase 5c link automatico
```

**Esempio**:
```
n=30
focus=diagnosi differenziale
workflow completo
```

---

# STRUTTURA DATABASE NOTION

## Database Argomenti
- **ID**: `1b5282519c2c80a68c37ce5e4bd56f22`
- **Data Source**: `collection://1b528251-9c2c-8065-a61e-000bfdfab7c7`

Properties:
- Nome (title)
- Pitch (text)
- Voci (relation ‚Üí Voci, relazione bidirezionale)
- Complessit√† (select): Semplice | Media | Complessa
- Tempo studio stimato (number)
- Tipo (select)
- Argomento primario (checkbox)
- Status argomento (select)
- Argomenti correlati (relation ‚Üí Argomenti, per link automatici)

## Database Voci (Unificato)
- **ID**: `290282519c2c801ea214d30b803c78f8`
- **Data Source**: `collection://29028251-9c2c-8024-bd71-000bcc303592`

Properties:
- Name (title)
- Categoria (multi_select): ["Eziologia", "Clinica", "Diagnosi", "Terapia"]
- Argomento (relation ‚Üí Argomenti)
- Note (text)
- Gruppo (self-relation)
- Sottogruppo (self-relation)
- Created time
- Last edited time

**Schema SQLite Voci**:
```sql
"Categoria" TEXT  -- JSON array: ["Eziologia"], ["Clinica"], etc
"Argomento" TEXT  -- JSON array di URL al database Argomenti
```

---

**CHECKPOINT ATTIVAZIONE**: Orchestrator v4.0 Scratchpad & Oneshot pronto. Quando utente allega file o scrive comando, attiva workflow appropriato.

**Novit√† v4.0** (rivoluzionarie):

**1. SCRATCHPAD System**:
- Tracking stato workflow in memoria chat
- Prerequisiti verificati automaticamente prima ogni fase
- Outputs salvati incrementalmente
- Validazioni tracciabili
- Performance metrics
- Comando `status` per visibilit√† completa

**2. ONESHOT Mode (default)**:
- Esecuzione automatica workflow completo senza conferme manuali
- Auto-avanzamento tra fasi dopo completamento
- Stop solo se errore o workflow completato
- Modalit√† manual disponibile con `manual_mode=true`

**3. Generazione Pagina Notion Ottimizzata**:
- Fase 1b: genera markdown GI√Ä Notion-ready (‚ñ∂, TAB, placeholders)
- Fase 2a: callout inseriti via str_replace (NO lista separata)
- Fase 4b: diagramma inserito via str_replace (NO output chat)
- Fase 5: ZERO rigenerazione pagina (upload diretto da scratchpad)
- Risparmio tempo: ~10-15 min

**4. Miglioramenti Performance**:
- Tempo totale: ~55-60 min (da ~70 min v2.5)
- Fase 2a: 1-2 min (da 3-5 min)
- Fase 4b: 1-2 min (da 3-5 min)
- Fase 5: 2-3 min (da 3-5 min)
- Zero duplicazione sforzi

**Workflow v4.0**:
```
Modalit√†: ONESHOT automatico
1a ‚Üí 1b (Notion-ready) ‚Üí 2a (str_replace) ‚Üí 3a ‚Üí 3b ‚Üí 4a ‚Üí 4b (str_replace) ‚Üí 5 (upload direct) ‚Üí 5c ‚Üí SUMMARY
```

**Mantenute da v3.0**:
- Anki: SOLO CORE (max 25 carte high-yield)
- Output: File anki_deck.txt con 1 carta/linea
- CCI enforcement rigoroso
- Anti-confusori Anki automatici
- Retry logic & cache termini
- Pre-flight validation
